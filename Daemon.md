### 进程组与会话组
进程组是多个进程的集合，进程组的ID和组长ID一样。当我们使用fork创建一个子进程时，就得到了一个进程组，这个进程组包含子进程和父进程
，进程组ID是父进程。一个进程组的进程可以获得控制终端的信号。
+ getpgid(0)获得当前进程的组ID
+ setpgid(pid_t pid,pid_t gpid)将进程ID为pid的放入组ID为gpid之中
+ setpgid(0,0)表示用当前进程新立一个进程组
会话组是多个进程组的集合，每个进程组完成不同的作业。
+ getsid(0)获得当前进程的会话组id
+ setsid() 用当前进程新另一个会话组
### Daemon
> Daemon守护进程运行在后台，又称为“后台服务进程”。它独立于控制终端和回话周期，执行某种任务。
守护进程不会被终端打断，也不会向终端输出信息，就算终端关闭，Daemon也会运转，直到整个系统关闭才退出。常见的命令末尾是d就是指deamon.

为了让守护进程和运行前的环境脱离开。需要:
+ 为它设立新会话，脱离父进程的控制
+ 改变工作目录。因为程序运行的时候，当前目录所在文件是不可修改的，要利用child("/")修改当前的目录
+ 修改文件掩码。将文件掩码设置为0.为后面创建文件提供最大权限[umask(0)](https://blog.csdn.net/Lina_ACM/article/details/51880617)
+ 关闭文件描述符。那些继承于父亲打开的文件描述符，可能不会被守护进程使用，我们需要关闭它们，包括标准输入，输出，错误。因为终端的控制命令不能传入。
### 一个简单的Daemon
```c
#include<fun.c>
void Daemon(){
  if(fork()){
    exit(0);
  }
  setsid();
  child("/");
  umask(0);
  for(int i=0;i<3;i++){
    close(i);
  }
  //...
}

int main(){
  Daemon();
  while(1);
}
```
